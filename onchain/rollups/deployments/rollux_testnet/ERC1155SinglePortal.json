{
  "address": "0xA7143F6f0f1d34EF39d75034A855b1c36D9A55D9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IInputBox",
          "name": "_inputBox",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC1155",
          "name": "_token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_app",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_baseLayerData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_execLayerData",
          "type": "bytes"
        }
      ],
      "name": "depositSingleERC1155Token",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getInputBox",
      "outputs": [
        {
          "internalType": "contract IInputBox",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x3378716ab1fb2de48684aec7ebd696b2d084279f6cf1ec4f4490b890995206c4",
  "receipt": {
    "to": "0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7",
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": null,
    "transactionIndex": 2,
    "gasUsed": "358256",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x98a58cb5342cadd424fbce3c36c46d97ab45b65fd7e3c8aa87f101d54093889a",
    "transactionHash": "0x3378716ab1fb2de48684aec7ebd696b2d084279f6cf1ec4f4490b890995206c4",
    "logs": [],
    "blockNumber": 12741894,
    "cumulativeGasUsed": "1298131",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xB572d5C134C0071ceF9B845E8CbDa56Bb39110bE"
  ],
  "numDeployments": 1,
  "solcInputHash": "ed73503a9e587d6de3f12590146837ca",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IInputBox\",\"name\":\"_inputBox\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_app\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_baseLayerData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_execLayerData\",\"type\":\"bytes\"}],\"name\":\"depositSingleERC1155Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInputBox\",\"outputs\":[{\"internalType\":\"contract IInputBox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_inputBox\":\"The input box used by the portal\"}},\"depositSingleERC1155Token(address,address,uint256,uint256,bytes,bytes)\":{\"params\":{\"_app\":\"The address of the application\",\"_baseLayerData\":\"Additional data to be interpreted by the base layer\",\"_execLayerData\":\"Additional data to be interpreted by the execution layer\",\"_token\":\"The ERC-1155 token contract\",\"_tokenId\":\"The identifier of the token being transferred\",\"_value\":\"Transfer amount\"}},\"getInputBox()\":{\"returns\":{\"_0\":\"The input box\"}}},\"title\":\"ERC-1155 Single Transfer Portal\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Constructs the portal.\"},\"depositSingleERC1155Token(address,address,uint256,uint256,bytes,bytes)\":{\"notice\":\"Transfer an ERC-1155 token to an application and add an input to the application's input box to signal such operation. The caller must enable approval for the portal to manage all of their tokens beforehand, by calling the `setApprovalForAll` function in the token contract.\"},\"getInputBox()\":{\"notice\":\"Get the input box used by this input relay.\"}},\"notice\":\"This contract allows anyone to perform single transfers of ERC-1155 tokens to an application while informing the off-chain machine.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/portals/ERC1155SinglePortal.sol\":\"ERC1155SinglePortal\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xe64b3445a3f638890af7ad92464cd18f1f202a2f5a7ed42dabf74317bae43303\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5ef46daa3b58ef2702279d514780316efaa952915ee1aa3396f041ee2982b0b4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/common/InputEncoding.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title Input Encoding Library\\n\\n/// @notice Defines the encoding of inputs added by core trustless and\\n/// permissionless contracts, such as portals and relays.\\nlibrary InputEncoding {\\n    /// @notice Encode an Ether deposit.\\n    /// @param sender The Ether sender\\n    /// @param value The amount of Ether being sent in Wei\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input\\n    function encodeEtherDeposit(\\n        address sender,\\n        uint256 value,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                sender, //              20B\\n                value, //               32B\\n                execLayerData //        arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-20 token deposit.\\n    /// @param token The token contract\\n    /// @param sender The token sender\\n    /// @param amount The amount of tokens being sent\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input\\n    function encodeERC20Deposit(\\n        IERC20 token,\\n        address sender,\\n        uint256 amount,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                amount, //              32B\\n                execLayerData //        arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-721 token deposit.\\n    /// @param token The token contract\\n    /// @param sender The token sender\\n    /// @param tokenId The token identifier\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeERC721Deposit(\\n        IERC721 token,\\n        address sender,\\n        uint256 tokenId,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(baseLayerData, execLayerData);\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                tokenId, //             32B\\n                data //                 arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-1155 single token deposit.\\n    /// @param token The ERC-1155 token contract\\n    /// @param sender The token sender\\n    /// @param tokenId The identifier of the token being transferred\\n    /// @param value Transfer amount\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeSingleERC1155Deposit(\\n        IERC1155 token,\\n        address sender,\\n        uint256 tokenId,\\n        uint256 value,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(baseLayerData, execLayerData);\\n        return\\n            abi.encodePacked(\\n                token, //               20B\\n                sender, //              20B\\n                tokenId, //             32B\\n                value, //               32B\\n                data //                 arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an ERC-1155 batch token deposit.\\n    /// @param token The ERC-1155 token contract\\n    /// @param sender The token sender\\n    /// @param tokenIds The identifiers of the tokens being transferred\\n    /// @param values Transfer amounts per token type\\n    /// @param baseLayerData Additional data to be interpreted by the base layer\\n    /// @param execLayerData Additional data to be interpreted by the execution layer\\n    /// @return The encoded input\\n    /// @dev `baseLayerData` should be forwarded to `token`.\\n    function encodeBatchERC1155Deposit(\\n        IERC1155 token,\\n        address sender,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata values,\\n        bytes calldata baseLayerData,\\n        bytes calldata execLayerData\\n    ) internal pure returns (bytes memory) {\\n        bytes memory data = abi.encode(\\n            tokenIds,\\n            values,\\n            baseLayerData,\\n            execLayerData\\n        );\\n        return\\n            abi.encodePacked(\\n                token, //                   20B\\n                sender, //                  20B\\n                data //                     arbitrary size\\n            );\\n    }\\n\\n    /// @notice Encode an application address relay.\\n    /// @param app The application address\\n    /// @return The encoded input\\n    function encodeApplicationAddressRelay(\\n        address app\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                app //                     20B\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x73a91ab85c3e9b4a39337efc22d8465802ce929c4db9453aa7bd9b507e594790\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/inputs/IInputBox.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\n/// @title Input Box interface\\ninterface IInputBox {\\n    /// @notice Emitted when an input is added to an application's input box.\\n    /// @param app The address of the application\\n    /// @param inputIndex The index of the input in the input box\\n    /// @param sender The address that sent the input\\n    /// @param input The contents of the input\\n    /// @dev MUST be triggered on a successful call to `addInput`.\\n    event InputAdded(\\n        address indexed app,\\n        uint256 indexed inputIndex,\\n        address sender,\\n        bytes input\\n    );\\n\\n    /// @notice Add an input to an application's input box.\\n    /// @param _app The address of the application\\n    /// @param _input The contents of the input\\n    /// @return The hash of the input plus some extra metadata\\n    /// @dev MUST fire an `InputAdded` event accordingly.\\n    ///      Input larger than machine limit will raise `InputSizeExceedsLimit` error.\\n    function addInput(\\n        address _app,\\n        bytes calldata _input\\n    ) external returns (bytes32);\\n\\n    /// @notice Get the number of inputs in an application's input box.\\n    /// @param _app The address of the application\\n    /// @return Number of inputs in the application's input box\\n    function getNumberOfInputs(address _app) external view returns (uint256);\\n\\n    /// @notice Get the hash of an input in an application's input box.\\n    /// @param _app The address of the application\\n    /// @param _index The index of the input in the application's input box\\n    /// @return The hash of the input at the provided index in the application's input box\\n    /// @dev `_index` MUST be in the interval `[0,n)` where `n` is the number of\\n    ///      inputs in the application's input box. See the `getNumberOfInputs` function.\\n    function getInputHash(\\n        address _app,\\n        uint256 _index\\n    ) external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x5545227421ef579ac471bb6e59c0dad5d2c8921648755059744b8fe7a7c5e015\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/inputs/IInputRelay.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IInputBox} from \\\"./IInputBox.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title Input Relay interface\\ninterface IInputRelay is IERC165 {\\n    // Permissionless functions\\n\\n    /// @notice Get the input box used by this input relay.\\n    /// @return The input box\\n    function getInputBox() external view returns (IInputBox);\\n}\\n\",\"keccak256\":\"0xafbf09d560b4637bd65c75c76ad991e583523a60d1a1d8f4c7dd430a3a9f6cf2\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/inputs/InputRelay.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IInputRelay} from \\\"./IInputRelay.sol\\\";\\nimport {IInputBox} from \\\"./IInputBox.sol\\\";\\nimport {ERC165, IERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n/// @title Input Relay\\n/// @notice This contract serves as a base for all the other input relays.\\ncontract InputRelay is IInputRelay, ERC165 {\\n    /// @notice The input box used by the input relay.\\n    IInputBox internal immutable inputBox;\\n\\n    /// @notice Constructs the input relay.\\n    /// @param _inputBox The input box used by the input relay\\n    constructor(IInputBox _inputBox) {\\n        inputBox = _inputBox;\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IInputRelay).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function getInputBox() external view override returns (IInputBox) {\\n        return inputBox;\\n    }\\n}\\n\",\"keccak256\":\"0x67afa2e8bb7f4da0c62a36c7a586e8e58529a167c8f349159ded6e69169a0a20\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/ERC1155SinglePortal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\nimport {IERC1155SinglePortal} from \\\"./IERC1155SinglePortal.sol\\\";\\nimport {InputRelay} from \\\"../inputs/InputRelay.sol\\\";\\nimport {IInputBox} from \\\"../inputs/IInputBox.sol\\\";\\nimport {InputEncoding} from \\\"../common/InputEncoding.sol\\\";\\n\\n/// @title ERC-1155 Single Transfer Portal\\n///\\n/// @notice This contract allows anyone to perform single transfers of\\n/// ERC-1155 tokens to an application while informing the off-chain machine.\\ncontract ERC1155SinglePortal is IERC1155SinglePortal, InputRelay {\\n    /// @notice Constructs the portal.\\n    /// @param _inputBox The input box used by the portal\\n    constructor(IInputBox _inputBox) InputRelay(_inputBox) {}\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(IERC165, InputRelay) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155SinglePortal).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function depositSingleERC1155Token(\\n        IERC1155 _token,\\n        address _app,\\n        uint256 _tokenId,\\n        uint256 _value,\\n        bytes calldata _baseLayerData,\\n        bytes calldata _execLayerData\\n    ) external override {\\n        _token.safeTransferFrom(\\n            msg.sender,\\n            _app,\\n            _tokenId,\\n            _value,\\n            _baseLayerData\\n        );\\n\\n        bytes memory input = InputEncoding.encodeSingleERC1155Deposit(\\n            _token,\\n            msg.sender,\\n            _tokenId,\\n            _value,\\n            _baseLayerData,\\n            _execLayerData\\n        );\\n\\n        inputBox.addInput(_app, input);\\n    }\\n}\\n\",\"keccak256\":\"0x2117f6c80e6ef0af6be1b6118d8ba84d2dff728f036d6e9c327b3092cad991ca\",\"license\":\"Apache-2.0 (see LICENSE)\"},\"contracts/portals/IERC1155SinglePortal.sol\":{\"content\":\"// (c) Cartesi and individual authors (see AUTHORS)\\n// SPDX-License-Identifier: Apache-2.0 (see LICENSE)\\n\\npragma solidity ^0.8.8;\\n\\nimport {IInputRelay} from \\\"../inputs/IInputRelay.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title ERC-1155 Single Transfer Portal interface\\ninterface IERC1155SinglePortal is IInputRelay {\\n    // Permissionless functions\\n\\n    /// @notice Transfer an ERC-1155 token to an application and add an input to\\n    /// the application's input box to signal such operation.\\n    ///\\n    /// The caller must enable approval for the portal to manage all of their tokens\\n    /// beforehand, by calling the `setApprovalForAll` function in the token contract.\\n    ///\\n    /// @param _token The ERC-1155 token contract\\n    /// @param _app The address of the application\\n    /// @param _tokenId The identifier of the token being transferred\\n    /// @param _value Transfer amount\\n    /// @param _baseLayerData Additional data to be interpreted by the base layer\\n    /// @param _execLayerData Additional data to be interpreted by the execution layer\\n    function depositSingleERC1155Token(\\n        IERC1155 _token,\\n        address _app,\\n        uint256 _tokenId,\\n        uint256 _value,\\n        bytes calldata _baseLayerData,\\n        bytes calldata _execLayerData\\n    ) external;\\n}\\n\",\"keccak256\":\"0xdf5099c9ae980a0224067eeb0281e8c9c10a56db168f2b3983eeee2764f33262\",\"license\":\"Apache-2.0 (see LICENSE)\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161060b38038061060b83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b60805161057a6100916000396000818160520152610178015261057a6000f3fe608060405234801561001057600080fd5b50600436106100405760003560e01c8062aace9a1461004557806301ffc9a714610081578063dec07dca146100a4575b600080fd5b6040516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681526020015b60405180910390f35b61009461008f366004610295565b6100b9565b6040519015158152602001610078565b6100b76100b2366004610327565b6100e4565b005b60006001600160e01b03198216636f603ee560e11b14806100de57506100de826101fe565b92915050565b604051637921219560e11b81526001600160a01b0389169063f242432a9061011a9033908b908b908b908b908b906004016103f8565b600060405180830381600087803b15801561013457600080fd5b505af1158015610148573d6000803e3d6000fd5b50505050600061015e8933898989898989610232565b604051631789cd6360e01b81529091506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690631789cd63906101af908b908590600401610463565b6020604051808303816000875af11580156101ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101f291906104a5565b50505050505050505050565b60006001600160e01b031982166255674d60e11b14806100de57506301ffc9a760e01b6001600160e01b03198316146100de565b606060008585858560405160200161024d94939291906104be565b604051602081830303815290604052905089898989846040516020016102779594939291906104f0565b60405160208183030381529060405291505098975050505050505050565b6000602082840312156102a757600080fd5b81356001600160e01b0319811681146102bf57600080fd5b9392505050565b6001600160a01b03811681146102db57600080fd5b50565b60008083601f8401126102f057600080fd5b50813567ffffffffffffffff81111561030857600080fd5b60208301915083602082850101111561032057600080fd5b9250929050565b60008060008060008060008060c0898b03121561034357600080fd5b883561034e816102c6565b9750602089013561035e816102c6565b96506040890135955060608901359450608089013567ffffffffffffffff8082111561038957600080fd5b6103958c838d016102de565b909650945060a08b01359150808211156103ae57600080fd5b506103bb8b828c016102de565b999c989b5096995094979396929594505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b03878116825286166020820152604081018590526060810184905260a06080820181905260009061043390830184866103cf565b98975050505050505050565b60005b8381101561045a578181015183820152602001610442565b50506000910152565b60018060a01b0383168152604060208201526000825180604084015261049081606085016020870161043f565b601f01601f1916919091016060019392505050565b6000602082840312156104b757600080fd5b5051919050565b6040815260006104d26040830186886103cf565b82810360208401526104e58185876103cf565b979650505050505050565b60006bffffffffffffffffffffffff19808860601b168352808760601b16601484015250846028830152836048830152825161053381606885016020870161043f565b91909101606801969550505050505056fea264697066735822122059e8ca0b900964c4ccfc1627d7eebd8ede66569f9a3bada7bf01d2c46a13e39e64736f6c63430008170033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100405760003560e01c8062aace9a1461004557806301ffc9a714610081578063dec07dca146100a4575b600080fd5b6040516001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001681526020015b60405180910390f35b61009461008f366004610295565b6100b9565b6040519015158152602001610078565b6100b76100b2366004610327565b6100e4565b005b60006001600160e01b03198216636f603ee560e11b14806100de57506100de826101fe565b92915050565b604051637921219560e11b81526001600160a01b0389169063f242432a9061011a9033908b908b908b908b908b906004016103f8565b600060405180830381600087803b15801561013457600080fd5b505af1158015610148573d6000803e3d6000fd5b50505050600061015e8933898989898989610232565b604051631789cd6360e01b81529091506001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690631789cd63906101af908b908590600401610463565b6020604051808303816000875af11580156101ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101f291906104a5565b50505050505050505050565b60006001600160e01b031982166255674d60e11b14806100de57506301ffc9a760e01b6001600160e01b03198316146100de565b606060008585858560405160200161024d94939291906104be565b604051602081830303815290604052905089898989846040516020016102779594939291906104f0565b60405160208183030381529060405291505098975050505050505050565b6000602082840312156102a757600080fd5b81356001600160e01b0319811681146102bf57600080fd5b9392505050565b6001600160a01b03811681146102db57600080fd5b50565b60008083601f8401126102f057600080fd5b50813567ffffffffffffffff81111561030857600080fd5b60208301915083602082850101111561032057600080fd5b9250929050565b60008060008060008060008060c0898b03121561034357600080fd5b883561034e816102c6565b9750602089013561035e816102c6565b96506040890135955060608901359450608089013567ffffffffffffffff8082111561038957600080fd5b6103958c838d016102de565b909650945060a08b01359150808211156103ae57600080fd5b506103bb8b828c016102de565b999c989b5096995094979396929594505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b03878116825286166020820152604081018590526060810184905260a06080820181905260009061043390830184866103cf565b98975050505050505050565b60005b8381101561045a578181015183820152602001610442565b50506000910152565b60018060a01b0383168152604060208201526000825180604084015261049081606085016020870161043f565b601f01601f1916919091016060019392505050565b6000602082840312156104b757600080fd5b5051919050565b6040815260006104d26040830186886103cf565b82810360208401526104e58185876103cf565b979650505050505050565b60006bffffffffffffffffffffffff19808860601b168352808760601b16601484015250846028830152836048830152825161053381606885016020870161043f565b91909101606801969550505050505056fea264697066735822122059e8ca0b900964c4ccfc1627d7eebd8ede66569f9a3bada7bf01d2c46a13e39e64736f6c63430008170033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_inputBox": "The input box used by the portal"
        }
      },
      "depositSingleERC1155Token(address,address,uint256,uint256,bytes,bytes)": {
        "params": {
          "_app": "The address of the application",
          "_baseLayerData": "Additional data to be interpreted by the base layer",
          "_execLayerData": "Additional data to be interpreted by the execution layer",
          "_token": "The ERC-1155 token contract",
          "_tokenId": "The identifier of the token being transferred",
          "_value": "Transfer amount"
        }
      },
      "getInputBox()": {
        "returns": {
          "_0": "The input box"
        }
      }
    },
    "title": "ERC-1155 Single Transfer Portal",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Constructs the portal."
      },
      "depositSingleERC1155Token(address,address,uint256,uint256,bytes,bytes)": {
        "notice": "Transfer an ERC-1155 token to an application and add an input to the application's input box to signal such operation. The caller must enable approval for the portal to manage all of their tokens beforehand, by calling the `setApprovalForAll` function in the token contract."
      },
      "getInputBox()": {
        "notice": "Get the input box used by this input relay."
      }
    },
    "notice": "This contract allows anyone to perform single transfers of ERC-1155 tokens to an application while informing the off-chain machine.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}